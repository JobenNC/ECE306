###############################################################################
#
# IAR C/C++ Compiler V6.10.2.50871/W32 for MSP430         05/Nov/2014  00:52:59
# Copyright 1996-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.10
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\Joseph\Documents\GitHub\ECE306\Proj6\main.c
#    Command line  =  
#        C:\Users\Joseph\Documents\GitHub\ECE306\Proj6\main.c -lC
#        C:\Users\Joseph\Documents\GitHub\ECE306\Proj6\Debug\List\ -o
#        C:\Users\Joseph\Documents\GitHub\ECE306\Proj6\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5739__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -Ol --multiplier=32
#        --multiplier_location=4C0 --hw_workaround=CPU40 --hw_workaround=CPU39
#        --code_model=large
#    List file     =  
#        C:\Users\Joseph\Documents\GitHub\ECE306\Proj6\Debug\List\main.lst
#    Object file   =  
#        C:\Users\Joseph\Documents\GitHub\ECE306\Proj6\Debug\Obj\main.r43
#
###############################################################################

C:\Users\Joseph\Documents\GitHub\ECE306\Proj6\main.c
      1          //===========================================================================
      2          // File Name : main.c
      3          //
      4          // Description: The main, 'while' operating system
      5          //
      6          // Author: Joseph Jarriel
      7          // Date: Sep 2014
      8          // Compiler: Built with IAR Embedded Workbench (6.10.5)
      9          // Globals: volatile unsigned int Time_Sequence, volatile char one_time,
     10          // volatile unsigned int five_msec_count, char *display_NCSU, char *display_HW3
     11          // Functions: main
     12          //===========================================================================
     13          
     14          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x322
   \   union <unnamed> _A_PJOUT_L
   \                     _A_PJOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5ee
   \   union <unnamed> _A_UCA1TXBUF_L
   \                     _A_UCA1TXBUF_L:
   \   000000                DS8 2
     15          #include  "functions.h"
     16          #include "macros.h"
     17          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          volatile unsigned int Time_Sequence;
   \                     Time_Sequence:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          volatile char one_time;
   \                     one_time:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          volatile unsigned int five_msec_count;
   \                     five_msec_count:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     21          volatile unsigned int startTimer = RESET;
   \                     startTimer:
   \   000000                DS8 2
     22          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          unsigned int driving = RESET;
   \                     driving:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          unsigned int reverse = RESET;
   \                     reverse:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     25          unsigned int startHalf = RESET;
   \                     startHalf:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     26          unsigned int halfTimer = RESET;
   \                     halfTimer:
   \   000000                DS8 2
     27          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     28          unsigned int L_Dir;
   \                     L_Dir:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     29          unsigned int R_Dir;
   \                     R_Dir:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     30          char test;
   \                     test:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     31          char *serial;
   \                     serial:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     32          int counter = 0;
   \                     counter:
   \   000000                DS8 2
     33          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     34          char *display_NCSU;
   \                     display_NCSU:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     35          char *display_HW3;
   \                     display_HW3:
   \   000000                DS8 2
     36          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     37          char toWrite;
   \                     toWrite:
   \   000000                DS8 1
     38          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     39          int test1=RESET;
   \                     test1:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     40          int test2=RESET;
   \                     test2:
   \   000000                DS8 2
     41          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     42          int timeOut = RESET;
   \                     timeOut:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     43          int dontWrite = RESET;
   \                     dontWrite:
   \   000000                DS8 2
     44          
     45          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     46          extern volatile int writeNext = RESET;
   \                     writeNext:
   \   000000                DS8 2
     47          

   \                                 In  segment CODE, align 2
     48          void main(void){
   \                     main:
     49          //===========================================================================
     50          // Function name: main
     51          //
     52          // Description: The main function.  Our 'while' OS
     53          // 
     54          // Passed : no variables passed
     55          // Locals: no variables declared
     56          // Returned: no values returned
     57          // Globals: Time_Sequence, one_time, five_msec_count
     58          // Calls: Init_Ports, Init_Clocks, Init_Conditions, Init_Timers, Init_LEDs,
     59          //      Init_LCD, five_msec_sleep, Switch_Process
     60          //
     61          // Author: Joseph Jarriel
     62          // Date: Sep 2014
     63          // Compiler: Built with IAR Embedded Workbench Version (6.10.5)
     64          //===========================================================================
     65            Init_Ports();                             // Initialize Ports
   \   000000   ........     CALLA   #Init_Ports
     66            Init_Clocks();                            // Initialize Clock System 
   \   000004   ........     CALLA   #Init_Clocks
     67            init_adc();
   \   000008   ........     CALLA   #init_adc
     68            Init_Serial_UCA1();                        // Initialize Serial Comms
   \   00000C   ........     CALLA   #Init_Serial_UCA1
     69            Init_Conditions();
   \   000010   ........     CALLA   #Init_Conditions
     70            PJOUT |= LED1;                            // Turn LED 1 on to indicate boot
   \   000014   92D32203     BIS.W   #0x1, &0x322
     71            Time_Sequence = RESET;                        // 
   \   000018   8243....     MOV.W   #0x0, &Time_Sequence
     72            Init_Timers();                            // Initialize Timers
   \   00001C   ........     CALLA   #Init_Timers
     73            five_msec_sleep(SLEEP_50);                      // 250 msec delay for the clock to settle
   \   000020   3C403200     MOV.W   #0x32, R12
   \   000024   ........     CALLA   #five_msec_sleep
     74            Init_LCD();                               // Initialize LCD
   \   000028   ........     CALLA   #Init_LCD
     75            five_msec_sleep(SLEEP_75);                      // 375 msec delay for the clock to settle
   \   00002C   3C404B00     MOV.W   #0x4b, R12
   \   000030   ........     CALLA   #five_msec_sleep
     76            Init_LEDs();                              // Initialize LEDs
   \   000034   ........     CALLA   #Init_LEDs
     77            display_NCSU = "   Callibrate   ";
   \   000038   B240........ MOV.W   #`?<Constant "   Callibrate   ">`, &display_NCSU
     78            display_HW3 =  "  IR Em Off  ";
   \   00003E   B240........ MOV.W   #`?<Constant "  IR Em Off  ">`, &display_HW3
     79            
     80          //  lcd_command(CLEAR_DISPLAY);
     81            five_msec_sleep(SLEEP_10); 
   \   000044   3C400A00     MOV.W   #0xa, R12
   \   000048   ........     CALLA   #five_msec_sleep
     82            lcd_out("1-Display 2-Clr",LCD_LINE_1);       // 16 characters max between quotes - line 1
   \   00004C   7D408000     MOV.B   #0x80, R13
   \   000050   3C40....     MOV.W   #`?<Constant "1-Display 2-Clr">`, R12
   \   000054   ........     CALLA   #lcd_out
     83            //lcd_out("LED On       ",LCD_LINE_2);
     84              //lcd_out(display_NCSU,LCD_LINE_1);       // 16 characters max between quotes - line 1
     85              //lcd_out(display_HW3,LCD_LINE_2);        // 16 characters max between quotes - line 2
     86              
     87          //------------------------------------------------------------------------------
     88          // Begining of the "While" Operating System
     89          //------------------------------------------------------------------------------
     90           ADC_Process();
   \   000058   ........     CALLA   #ADC_Process
     91           L_Dir = L_FORWARD;
   \   00005C   B2404000.... MOV.W   #0x40, &L_Dir
     92           R_Dir = R_FORWARD;
   \   000062   B2401000.... MOV.W   #0x10, &R_Dir
     93           serial="               ";
   \   000068   B240........ MOV.W   #`?<Constant "               ">`, &serial
   \   00006E   3A3C         JMP     ??main_0
     94           while(ALWAYS) {    
     95             
     96             //UCA1TXBUF = 'U';
     97             //if (nib2 < numRange) nib2 = nib2 + numOffset;
     98             //       else nib2 = nib2 + charOffset;
     99             test1 = usb_rx_ring_wr;
    100             test2 = usb_rx_ring_rd;
    101             if (test1 != test2)
    102                {
    103                  if ((UCTXIFG))
    104                  {
    105                    if (usb_rx_ring_rd > 6)
    106                    {
    107                      usb_rx_ring_rd =0;
    108                      test = USB_Char_Rx[7];
    109                      test++;
    110                    }
    111                    else
    112                    {
    113                      usb_rx_ring_rd++;
   \                     ??main_1:
   \   000070   9253....     ADD.W   #0x1, &usb_rx_ring_rd
    114                      test = USB_Char_Rx[usb_rx_ring_wr];
   \   000074   1F42....     MOV.W   &usb_rx_ring_wr, R15
   \   000078   D24F........ MOV.B   USB_Char_Rx(R15), &test
    115                    }
    116                    
    117                    //test = test + numOffset;
    118                    
    119                    lcd_clear();
   \                     ??main_2:
   \   00007E   ........     CALLA   #lcd_clear
    120                    
    121                    //test = test + 48;
    122                    toWrite = test/10;
   \   000082   5C42....     MOV.B   &test, R12
   \   000086   7E400A00     MOV.B   #0xa, R14
   \   00008A   ........     CALLA   #?DivMod8u
   \   00008E   C24C....     MOV.B   R12, &toWrite
    123                    serial[char1]=toWrite + 48;
   \   000092   5E42....     MOV.B   &toWrite, R14
   \   000096   7E503000     ADD.B   #0x30, R14
   \   00009A   1F42....     MOV.W   &serial, R15
   \   00009E   CF4E0800     MOV.B   R14, 0x8(R15)
    124                    
    125                    toWrite = test % 10;
   \   0000A2   5C42....     MOV.B   &test, R12
   \   0000A6   7E400A00     MOV.B   #0xa, R14
   \   0000AA   ........     CALLA   #?DivMod8u
   \   0000AE   C24E....     MOV.B   R14, &toWrite
    126                    
    127                    serial[char2] = toWrite + 48;
   \   0000B2   5E42....     MOV.B   &toWrite, R14
   \   0000B6   7E503000     ADD.B   #0x30, R14
   \   0000BA   1F42....     MOV.W   &serial, R15
   \   0000BE   CF4E0900     MOV.B   R14, 0x9(R15)
    128                    //if ((int) test < 10)
    129                    //{
    130                    //    toWrite = test + 48;
    131                    //}     
    132                    //serial[char1]=toWrite;
    133                    
    134                    lcd_out(serial, LCD_LINE_1);
   \   0000C2   7D408000     MOV.B   #0x80, R13
   \   0000C6   1C42....     MOV.W   &serial, R12
   \   0000CA   ........     CALLA   #lcd_out
    135                    
    136                    test++;
   \   0000CE   D253....     ADD.B   #0x1, &test
    137                    //test = test - 48;
    138                    
    139                    newFM(200);
   \   0000D2   3C40C800     MOV.W   #0xc8, R12
   \   0000D6   ........     CALLA   #newFM
    140                    UCA1TXBUF = test;
   \   0000DA   5F42....     MOV.B   &test, R15
   \   0000DE   4F4F         MOV.B   R15, R15
   \   0000E0   824FEE05     MOV.W   R15, &0x5ee
   \                     ??main_0:
   \   0000E4   9242........ MOV.W   &usb_rx_ring_wr, &test1
   \   0000EA   9242........ MOV.W   &usb_rx_ring_rd, &test2
   \   0000F0   9292........ CMP.W   &test2, &test1
   \   0000F6   F627         JEQ     ??main_0
   \   0000F8   B2900700.... CMP.W   #0x7, &usb_rx_ring_rd
   \   0000FE   B83B         JL      ??main_1
   \   000100   8243....     MOV.W   #0x0, &usb_rx_ring_rd
   \   000104   D242........ MOV.B   &USB_Char_Rx + 7, &test
   \   00010A   D253....     ADD.B   #0x1, &test
   \   00010E   B73F         JMP     ??main_2
   \   000110   0343         NOP
   \   000112                REQUIRE _A_PJOUT_L
   \   000112                REQUIRE _A_UCA1TXBUF_L
    141                  }
    142             //     nib1 = (nib1Mask&ADC_RD);
    143             //       nib1 = (nib1Mask&ADC_RD);
    144             //       if (nib1 < numRange) nib1 = nib1 + numOffset;
    145             //       else nib1 = nib1 + charOffset;
    146             //   
    147             //       nib2 = (nib2Mask&ADC_RD)>>shift4;
    148             //       if (nib2 < numRange) nib2 = nib2 + numOffset;
    149             //       else nib2 = nib2 + charOffset;
    150             //   
    151             //       nib3 = (nib3Mask&ADC_RD)>>shift8;
    152             //       nib3 = nib3 + numOffset;
    153             //   
    154             //       nib4 = RESET + numOffset;
    155             //   
    156             //       display_One="            ";
    157             //       display_One[char1]=nib4;
    158             //       display_One[char2]=nib3;
    159             //       display_One[char3]=nib2;
    160             //       display_One[char4]=nib1;
    161                }
    162             
    163             
    164             
    165             //-------------------------------------------------------
    166             //if (writeNext)
    167             //{
    168            
    169             //   if ((UCTXIFG))
    170             //   {
    171             //     timeOut = RESET;
    172             //     
    173             //     //
    174             //     //
    175             //     UCA1TXBUF = toWrite;
    176             //   
    177             //     newFM(HUNDRED_MIL);
    178             //     if (usb_rx_ring_wr == RESET)
    179             //     {
    180             //       dontWrite = START;
    181             //       break;
    182             //     }
    183             //
    184             //   
    185             //     while (START)
    186             //     {
    187             //       newFM(START);
    188             //       test1 = usb_rx_ring_wr;
    189             //       test2 = usb_rx_ring_rd;
    190             //       if (test1 != test2) break;
    191             //     }
    192             //   
    193             //     usb_rx_ring_rd++;
    194             //     test = USB_Char_Rx[usb_rx_ring_wr];
    195             //   
    196             //     serial[char1-1+j]=test;
    197             //     }
    198             //
    199             // lcd_clear();
    200             // if (!dontWrite) lcd_out(serial, LCD_LINE_1);
    201             // else dontWrite = RESET;
    202             // //else dontWrite = 0;
    203             // usb_rx_ring_wr = RESET;
    204             // usb_rx_ring_rd = RESET;
    205             // usb_tx_ring_wr = RESET;
    206             // usb_tx_ring_rd = RESET;
    207             // 
    208             // if (i >= 100) writeNext = 0;
    209             //}
    210             //}
    211           }
    212          }

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "   Callibrate   ">`:
   \   000000   20202043616C DC8 "   Callibrate   "
   \            6C6962726174
   \            6520202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "  IR Em Off  ">`:
   \   000000   202049522045 DC8 "  IR Em Off  "
   \            6D204F666620
   \            2000        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "1-Display 2-Clr">`:
   \   000000   312D44697370 DC8 "1-Display 2-Clr"
   \            6C617920322D
   \            436C7200    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "               ">`:
   \   000000   202020202020 DC8 "               "
   \            202020202020
   \            20202000    

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   main
        4   -> ADC_Process
        4   -> Init_Clocks
        4   -> Init_Conditions
        4   -> Init_LCD
        4   -> Init_LEDs
        4   -> Init_Ports
        4   -> Init_Serial_UCA1
        4   -> Init_Timers
        4   -> five_msec_sleep
        4   -> init_adc
        4   -> lcd_clear
        4   -> lcd_out
        4   -> newFM


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "               ">
      17  ?<Constant "   Callibrate   ">
      14  ?<Constant "  IR Em Off  ">
      16  ?<Constant "1-Display 2-Clr">
       2  L_Dir
       2  R_Dir
       2  Time_Sequence
       2  _A_PJOUT_L
       2  _A_UCA1TXBUF_L
       2  counter
       2  display_HW3
       2  display_NCSU
       2  dontWrite
       2  driving
       2  five_msec_count
       2  halfTimer
     274  main
       1  one_time
       2  reverse
       2  serial
       2  startHalf
       2  startTimer
       1  test
       2  test1
       2  test2
       2  timeOut
       1  toWrite
       2  writeNext

 
 274 bytes in segment CODE
   4 bytes in segment DATA16_AN
  63 bytes in segment DATA16_C
  39 bytes in segment DATA16_Z
 
 274 bytes of CODE  memory
  63 bytes of CONST memory
  39 bytes of DATA  memory (+ 4 bytes shared)

Errors: none
Warnings: none
