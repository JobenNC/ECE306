###############################################################################
#
# IAR C/C++ Compiler V6.10.2.50871/W32 for MSP430         02/Nov/2014  22:27:42
# Copyright 1996-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.10
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\Joseph\Documents\GitHub\ECE306\Hw8\main.c
#    Command line  =  
#        C:\Users\Joseph\Documents\GitHub\ECE306\Hw8\main.c -lC
#        C:\Users\Joseph\Documents\GitHub\ECE306\Hw8\Debug\List\ -o
#        C:\Users\Joseph\Documents\GitHub\ECE306\Hw8\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5739__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -Ol --multiplier=32
#        --multiplier_location=4C0 --hw_workaround=CPU40 --hw_workaround=CPU39
#        --code_model=large
#    List file     =  
#        C:\Users\Joseph\Documents\GitHub\ECE306\Hw8\Debug\List\main.lst
#    Object file   =  
#        C:\Users\Joseph\Documents\GitHub\ECE306\Hw8\Debug\Obj\main.r43
#
###############################################################################

C:\Users\Joseph\Documents\GitHub\ECE306\Hw8\main.c
      1          //===========================================================================
      2          // File Name : main.c
      3          //
      4          // Description: The main, 'while' operating system
      5          //
      6          // Author: Joseph Jarriel
      7          // Date: Sep 2014
      8          // Compiler: Built with IAR Embedded Workbench (6.10.5)
      9          // Globals: volatile unsigned int Time_Sequence, volatile char one_time,
     10          // volatile unsigned int five_msec_count, char *display_NCSU, char *display_HW3
     11          // Functions: main
     12          //===========================================================================
     13          
     14          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x322
   \   union <unnamed> _A_PJOUT_L
   \                     _A_PJOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5ee
   \   union <unnamed> _A_UCA1TXBUF_L
   \                     _A_UCA1TXBUF_L:
   \   000000                DS8 2
     15          #include  "functions.h"
     16          #include "macros.h"
     17          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          volatile unsigned int Time_Sequence;
   \                     Time_Sequence:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          volatile char one_time;
   \                     one_time:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          volatile unsigned int five_msec_count;
   \                     five_msec_count:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     21          volatile unsigned int startTimer = RESET;
   \                     startTimer:
   \   000000                DS8 2
     22          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          unsigned int driving = RESET;
   \                     driving:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          unsigned int reverse = RESET;
   \                     reverse:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     25          unsigned int startHalf = RESET;
   \                     startHalf:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     26          unsigned int halfTimer = RESET;
   \                     halfTimer:
   \   000000                DS8 2
     27          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     28          unsigned int L_Dir;
   \                     L_Dir:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     29          unsigned int R_Dir;
   \                     R_Dir:
   \   000000                DS8 2
     30          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     31          char *display_NCSU;
   \                     display_NCSU:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     32          char *display_HW3;
   \                     display_HW3:
   \   000000                DS8 2
     33          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     34          int test1=0;
   \                     test1:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     35          int test2=0;
   \                     test2:
   \   000000                DS8 2
     36          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     37          extern volatile int writeNext = 0;
   \                     writeNext:
   \   000000                DS8 2
     38          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     39          char test;
   \                     test:
   \   000000                DS8 1
     40          

   \                                 In  segment CODE, align 2
     41          void main(void){
   \                     main:
     42          //===========================================================================
     43          // Function name: main
     44          //
     45          // Description: The main function.  Our 'while' OS
     46          // 
     47          // Passed : no variables passed
     48          // Locals: no variables declared
     49          // Returned: no values returned
     50          // Globals: Time_Sequence, one_time, five_msec_count
     51          // Calls: Init_Ports, Init_Clocks, Init_Conditions, Init_Timers, Init_LEDs,
     52          //      Init_LCD, five_msec_sleep, Switch_Process
     53          //
     54          // Author: Joseph Jarriel
     55          // Date: Sep 2014
     56          // Compiler: Built with IAR Embedded Workbench Version (6.10.5)
     57          //===========================================================================
     58            Init_Ports();                             // Initialize Ports
   \   000000   ........     CALLA   #Init_Ports
     59            Init_Clocks();                            // Initialize Clock System 
   \   000004   ........     CALLA   #Init_Clocks
     60            init_adc();
   \   000008   ........     CALLA   #init_adc
     61            Init_Serial_UCA1();                        // Initialize Serial Comms
   \   00000C   ........     CALLA   #Init_Serial_UCA1
     62            Init_Conditions();
   \   000010   ........     CALLA   #Init_Conditions
     63            PJOUT |= LED1;                            // Turn LED 1 on to indicate boot
   \   000014   92D32203     BIS.W   #0x1, &0x322
     64            Time_Sequence = RESET;                        // 
   \   000018   8243....     MOV.W   #0x0, &Time_Sequence
     65            Init_Timers();                            // Initialize Timers
   \   00001C   ........     CALLA   #Init_Timers
     66            five_msec_sleep(SLEEP_50);                      // 250 msec delay for the clock to settle
   \   000020   3C403200     MOV.W   #0x32, R12
   \   000024   ........     CALLA   #five_msec_sleep
     67            Init_LCD();                               // Initialize LCD
   \   000028   ........     CALLA   #Init_LCD
     68            five_msec_sleep(SLEEP_75);                      // 375 msec delay for the clock to settle
   \   00002C   3C404B00     MOV.W   #0x4b, R12
   \   000030   ........     CALLA   #five_msec_sleep
     69            Init_LEDs();                              // Initialize LEDs
   \   000034   ........     CALLA   #Init_LEDs
     70            display_NCSU = "   Callibrate   ";
   \   000038   B240........ MOV.W   #`?<Constant "   Callibrate   ">`, &display_NCSU
     71            display_HW3 =  "  IR Em Off  ";
   \   00003E   B240........ MOV.W   #`?<Constant "  IR Em Off  ">`, &display_HW3
     72            
     73          //  lcd_command(CLEAR_DISPLAY);
     74            five_msec_sleep(SLEEP_10); 
   \   000044   3C400A00     MOV.W   #0xa, R12
   \   000048   ........     CALLA   #five_msec_sleep
     75            lcd_out("Make Selection",LCD_LINE_1);       // 16 characters max between quotes - line 1
   \   00004C   7D408000     MOV.B   #0x80, R13
   \   000050   3C40....     MOV.W   #`?<Constant "Make Selection">`, R12
   \   000054   ........     CALLA   #lcd_out
     76            //lcd_out("LED On       ",LCD_LINE_2);
     77              //lcd_out(display_NCSU,LCD_LINE_1);       // 16 characters max between quotes - line 1
     78              //lcd_out(display_HW3,LCD_LINE_2);        // 16 characters max between quotes - line 2
     79              
     80          //------------------------------------------------------------------------------
     81          // Begining of the "While" Operating System
     82          //------------------------------------------------------------------------------
     83           ADC_Process();
   \   000058   ........     CALLA   #ADC_Process
     84           L_Dir = L_FORWARD;
   \   00005C   B2404000.... MOV.W   #0x40, &L_Dir
     85           R_Dir = R_FORWARD;
   \   000062   B2401000.... MOV.W   #0x10, &R_Dir
     86           while(ALWAYS) {    
     87             
     88             // Can the Operating system run
     89             //newFM(20);
     90             
     91             //UCA1TXBUF = 'U';
     92             
     93             if (writeNext)
   \                     ??main_0:
   \   000068   8293....     CMP.W   #0x0, &writeNext
   \   00006C   FD27         JEQ     ??main_0
     94             {
     95                //UCA1TXBUF = 'u';
     96                writeNext = 0;
   \   00006E   8243....     MOV.W   #0x0, &writeNext
     97                
     98                while (!UCTXIFG)
     99                {
    100                }
    101                UCA1TXBUF = 'u';
   \   000072   B2407500EE05 MOV.W   #0x75, &0x5ee
    102                
    103                while (1)
    104                {
    105                  test1 = usb_rx_ring_wr;
   \                     ??main_1:
   \   000078   9242........ MOV.W   &usb_rx_ring_wr, &test1
    106                  test2 = usb_rx_ring_rd;
   \   00007E   9242........ MOV.W   &usb_rx_ring_rd, &test2
    107                  if (test1 != test2) break;
   \   000084   9292........ CMP.W   &test2, &test1
   \   00008A   F627         JEQ     ??main_1
    108                }
    109                
    110                /////while (!UCTXIFG)
    111                ////{
    112                ////}
    113                ////UCA1TXBUF = 'u';
    114                
    115                usb_rx_ring_rd++;
   \   00008C   9253....     ADD.W   #0x1, &usb_rx_ring_rd
    116                test = USB_Char_Rx[usb_rx_ring_wr];
   \   000090   1F42....     MOV.W   &usb_rx_ring_wr, R15
   \   000094   D24F........ MOV.B   USB_Char_Rx(R15), &test
    117                int stop = 0;
                           ^
Warning[Pe177]: variable "stop" was declared but never referenced
   \   00009A   0F43         MOV.W   #0x0, R15
   \   00009C   E53F         JMP     ??main_0
   \   00009E   0343         NOP
   \   0000A0                REQUIRE _A_PJOUT_L
   \   0000A0                REQUIRE _A_UCA1TXBUF_L
    118             }
    119              //Code for tx rx
    120          
    121              //
    122          
    123           // //switch(Time_Sequence){
    124           // //  case TSEQ_250:                               // 1000 msec  
    125           // //    if(one_time){
    126           // //      //Init_LEDs();                      // Initialize LEDs
    127           // //      one_time = RESET;
    128           // //    }
    129           // //    Time_Sequence = RESET;                    // 
    130           // //  case TSEQ_200:                               // 1000 msec  
    131           // //    if(one_time){
    132           // //      //PJOUT |= LED4;                      // Change State of LED 4
    133           // //      //P3OUT |= LED5;                      // Change State of LED 5
    134           // //      one_time = RESET;
    135           // //    }
    136           // //  case TSEQ_150:                               // 750 msec  
    137           // //    if(one_time){
    138           // //      //PJOUT |= LED3;                      // Change State of LED 3
    139           // //      //P3OUT |= LED6;                      // Change State of LED 6
    140           // //      one_time = RESET;
    141           // //    }
    142           // //  case TSEQ_100:                               // 500 msec  
    143           // //    if(one_time){
    144           // //      //PJOUT |= LED2;                      // Change State of LED 2
    145           // //      //P3OUT |= LED7;                      // Change State of LED 7
    146           // //      one_time = RESET;
    147           // //    }
    148           // //  case  TSEQ_50:                               // 250 msec  
    149           // //    if(one_time){
    150           //  //     //PJOUT |= LED1;                      // Change State of LED 1
    151           //  //     //P3OUT |= LED8;                      // Change State of LED 8
    152           // //      one_time = RESET;
    153           // //    }
    154           // //    break;                                // 
    155           // //  default: break; 
    156           // //}
    157           // //Switches_Process();                       // Check for switch state change
    158           // 
    159           // if (starting)
    160           // {
    161           //   newFM(HALF_SEC);
    162           //   starting = RESET;
    163           // }
    164           // 
    165           // if ((drive) && ~(driving))
    166           // {
    167           //     //newFM(200);
    168           //     driving = START;
    169           // }
    170           // if (driving)
    171           // {
    172           //   
    173           //   //if ((ADC_LD > (LED_Black_LD-350)) && (ADC_RD < (LED_Black_RD-350)))
    174           //   //{
    175           //   //  P3OUT &= ~L_FORWARD;
    176           //   //  P3OUT |= R_FORWARD;
    177           //   //  newFM(20);
    178           //   //  P3OUT &= ~L_FORWARD;
    179           //   //  P3OUT &= ~R_FORWARD;
    180           //   //}
    181           //   
    182           //   //else if ((ADC_LD < (LED_Black_LD-350)) && (ADC_RD > (LED_Black_RD-350)))
    183           //   //{
    184           //   //  P3OUT |= L_FORWARD;
    185           //   //  P3OUT &= ~R_FORWARD;
    186           //   //  newFM(20);
    187           //   //  P3OUT &= ~L_FORWARD;
    188           //   //  P3OUT &= ~R_FORWARD;
    189           //   //}
    190           //   
    191           //   if ((ADC_LD < (LED_Black_LD - offLine)) && (ADC_RD < (LED_Black_RD - offLine)))
    192           //   {
    193           //     P3OUT |= L_Dir;
    194           //     P3OUT |= R_Dir;
    195           //     newFM(SEVENTH);
    196           //     P3OUT &= ~L_Dir;
    197           //     P3OUT &= ~R_Dir;
    198           //   }
    199           //   
    200           //   else
    201           //   {
    202           //     P3OUT &= ~L_Dir;
    203           //     P3OUT &= ~R_Dir;
    204           //     if (reverse == RESET)
    205           //     {
    206           //       newFM(HALF_SEC);
    207           //       L_Dir = L_REVERSE;
    208           //       R_Dir = R_REVERSE;
    209           //       
    210           //       startTimer = START;
    211           //       P3OUT |= L_Dir;
    212           //       P3OUT |= R_Dir;
    213           //       newFM(seventy);
    214           //       P3OUT &= ~L_Dir;
    215           //       P3OUT &= ~R_Dir;
    216           //       
    217           //       reverse++;
    218           //     }
    219           //     else if (reverse == START)
    220           //     {
    221           //       
    222           //       startTimer = RESET;
    223           //       P3OUT &= ~L_Dir;
    224           //       P3OUT &= ~R_Dir;
    225           //       
    226           //       L_Dir = L_FORWARD;
    227           //       R_Dir = R_FORWARD;
    228           //       
    229           //       newFM(HALF_SEC);
    230           //       
    231           //       P3OUT |= L_Dir;
    232           //       P3OUT |= R_Dir;
    233           //       newFM(timerCount/HALF);
    234           //       P3OUT &= ~L_Dir;
    235           //       P3OUT &= ~R_Dir;
    236           //       
    237           //       newFM(ONE_SEC);
    238           //       
    239           //       L_Dir = R_FORWARD;
    240           //       R_Dir = L_REVERSE;
    241           //       P3OUT |= L_Dir;
    242           //       P3OUT |= R_Dir;
    243           //       newFM(twoLoop);
    244           //       P3OUT &= ~L_Dir;
    245           //       P3OUT &= ~R_Dir;
    246           //       
    247           //       newFM(ONE_SEC);
    248           //       
    249           //       L_Dir = R_REVERSE;
    250           //       R_Dir = L_FORWARD;
    251           //       P3OUT |= L_Dir;
    252           //       P3OUT |= R_Dir;
    253           //       newFM(twoLoop);
    254           //       P3OUT &= ~L_Dir;
    255           //       P3OUT &= ~R_Dir;
    256           //       
    257           //       
    258           //       reverse++;
    259           //       driving = RESET;
    260           //       drive = RESET;
    261           //     }
    262           //     
    263           //     else
    264           //     {
    265           //       P3OUT &= ~L_Dir;
    266           //       P3OUT &= ~R_Dir;
    267           //     }
    268           //   }
    269           // }
    270           // //ADC_Process();
    271           // //if(Time_Sequence > TSEQ_250){
    272           // //  Time_Sequence = RESET;
    273           // //}
    274           }
    275          //------------------------------------------------------------------------------
    276          }

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "   Callibrate   ">`:
   \   000000   20202043616C DC8 "   Callibrate   "
   \            6C6962726174
   \            6520202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "  IR Em Off  ">`:
   \   000000   202049522045 DC8 "  IR Em Off  "
   \            6D204F666620
   \            2000        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Make Selection">`:
   \   000000   4D616B652053 DC8 "Make Selection"
   \            656C65637469
   \            6F6E00      

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   main
        4   -> ADC_Process
        4   -> Init_Clocks
        4   -> Init_Conditions
        4   -> Init_LCD
        4   -> Init_LEDs
        4   -> Init_Ports
        4   -> Init_Serial_UCA1
        4   -> Init_Timers
        4   -> five_msec_sleep
        4   -> init_adc
        4   -> lcd_out


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      17  ?<Constant "   Callibrate   ">
      14  ?<Constant "  IR Em Off  ">
      15  ?<Constant "Make Selection">
       2  L_Dir
       2  R_Dir
       2  Time_Sequence
       2  _A_PJOUT_L
       2  _A_UCA1TXBUF_L
       2  display_HW3
       2  display_NCSU
       2  driving
       2  five_msec_count
       2  halfTimer
     160  main
       1  one_time
       2  reverse
       2  startHalf
       2  startTimer
       1  test
       2  test1
       2  test2
       2  writeNext

 
 160 bytes in segment CODE
   4 bytes in segment DATA16_AN
  46 bytes in segment DATA16_C
  30 bytes in segment DATA16_Z
 
 160 bytes of CODE  memory
  46 bytes of CONST memory
  30 bytes of DATA  memory (+ 4 bytes shared)

Errors: none
Warnings: 1
